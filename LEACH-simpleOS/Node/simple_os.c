//
// DO NOT EDIT THIS FILE
//
//
// Summer School polling-to-event-handler support
//

//
// Need to modify radio.c and timer.c to support this
//
// radio.c
//    - modify init() and send() to leave radio in RX state
//    - add radio_tx_done() - set a flag in send(), and clear in tx_done()
//    - add radio_rxed()
//    - modify radio_recv() as radio already in RX state on entry
// timer.c
//    - add ticked()
//    - add ticked flag - set in ISR and clear in ticked()
//
#include <avr/io.h>
#include <stdio.h>
#include <avr/eeprom.h>

#include "leds.h"
#include "simple_os.h"
#include "serial.h"
#include "radio.h"
#include "button.h"
#include "hw_timer.h"
#include "app.h"

#define True 1
#define False 0

#define BUFFER_LEN 128
static unsigned char buffer[BUFFER_LEN];

#define TIMERS 10
static timer* os_timer_list[TIMERS];

unsigned char id=0;

static void os_timer_add(timer *t)
{
	unsigned char i;
	// if already in list, just ignore the request
	for (i=0; i<TIMERS; i++) {
		if (os_timer_list[i]==t)
		return;
	}
	// find an empty space, and add the timer
	for (i=0; i<TIMERS; i++) {
		if (os_timer_list[i]==0) {
			os_timer_list[i] = t;
			return;
		}
	}
	// no space - just ignore the request...
}

void timer_init(timer *t, unsigned char t_type, unsigned short t_initial, unsigned short t_period)
{
	t->active = False;
	t->pending = False;
	t->type = t_type;
	t->expired = False;
	t->initial = t_initial;
	t->period = t_period;
	os_timer_add(t);
}

void timer_start(timer *t)
{
	if (!t->active) {
		t->active = True;
		t->pending = False;
		t->expired = False;
		t->remaining = t->initial;
	}
	os_timer_add(t);
}

void timer_stop(timer *t)
{
	t->active = False;
	t->pending = False;
}

static void os_timer_tick(timer *t, bool isMilli)
{
	if (t!=NULL) {
			if (t->active) {
			if (t->remaining>0) {
				// decrement remaining
				if (isMilli) {
					// process millisecond timers
					if (t->type==TIMER_MILLISECONDS) {
						t->remaining--;
					}
				}
				else {
					// process second timers
					if (t->type==TIMER_SECONDS) {
						t->remaining--;
					}
				}
				// process expired timers
				if (t->remaining==0) {
					t->expired = True;
					if (t->period>0)
						t->pending = True;
					else
						t->pending = False;
					t->active = False;
				}
			}
		}
	}
}

static void os_timer_init()
{
   int i;
   for (i=0; i<TIMERS; i++)
      os_timer_list[i] = (timer *)0;
   hw_timer_init();
}

static unsigned char os_timer_expired(timer *t)
{
	if (t!=NULL)
		if (t->expired)
			return True;
	return False;
}

static void os_timer_reset(timer *t)
{
	t->expired = false;
	if ((t->pending) && (t->period>0)) {
		t->remaining = t->period;
		t->active = true;
	}
	t->pending = false;
}

unsigned long os_tick=0;
static unsigned char timer_milli_ticked()
{
  if ((hw_timer_now_us()) > os_tick) {
	  os_tick = hw_timer_now_us() + 1000;
	  return 1;
  }
  return 0;
}


// Note: set a breakpoint at function application_start() to debug your application
int main() {

   int i;
   bool pressed=false;
   unsigned short millis=0;

   //
   // Startup platform and timers
   //

   //platform_init();
   os_timer_init();

   //
   // Call application 'main'
   //

   application_start();

   //
   // Event handling loop
   //
   for (;;) {

      // process transmit done

	  if (radio_tx_done()) {
		  application_radio_tx_done();
	  }

      // process received messages

	  if (radio_rxed()) {
		  unsigned short dst, src;
		  unsigned char valid, energy, lqi;
		  unsigned char len = radio_recv(buffer,BUFFER_LEN,&dst,&src,&valid,&energy,&lqi);
		  if (valid) {
			  if ( (dst==radio_getid()) || (dst==0xFFFF) || (radio_rx_all()) )
				  application_radio_rx_msg(dst,src,len,buffer);
		  }
	  }

      if (timer_milli_ticked()) {
			// tick the millisecond timers
			for (i=0; i<TIMERS; i++)
  				os_timer_tick(os_timer_list[i], True);
			// every 1000 milliseconds, tick the second timers
			millis++;
			if (millis>=1000) {
				millis = 0;
				for (i=0; i<TIMERS; i++)
  					os_timer_tick(os_timer_list[i], False);
			}
	  }

      for (i=0; i<TIMERS; i++) {
		  if (os_timer_expired(os_timer_list[i])) {
		     application_timer_tick(os_timer_list[i]);
			 os_timer_reset(os_timer_list[i]);
		     break; // so that we get a chance to run application_radio_tx_done() before next timer event (which may want to send())
		 }
	  }

	  if (button_pressed() && (!pressed)) {
	  	pressed = true;
		application_button_pressed();
	  }
	  else if (button_released() && (pressed)) {
	  	pressed = false;
		application_button_released();
	  }

   }

}

